Total: 14h

ToDo: 
- Control Unit (unique for each pc architecture)
    decoder receives opcode from PM and sends it to ALU/registers
    add PC and incrementer (needs an adder)
    PC has to be a register, that connects to PM select (2*numbits), and can be written to from PM or RAM PC register addr
    also has RAMPage select register (2-bytes: store AB->rampage)
    comparator flags and PC register 
    add stack pointer and function return
    

rampage write enable should be opcode
cmp flags always read/writable
return addr and stack pointer. sp should point in ram to ra, so can have call from call
clock tick is logic. needs to be gates
need a halt/run flag that gets set with opcode halt or pc overflow

now let's make the control unit. this will be a class that will be inherited by the control unit for each specific 
computer design. this parent class should take the numbits in constructor, have a program counter register of size 
2*numbits, an adder wired to pc for incrementing it. the output of the incrementer needs to be AND'ed with a flag so 
that we can write to the PC from outside (program memory or ram for jumps), we will invert that flag with the right opcodes to 
write to pc from other sources. the output of PC should be connected to the addr select of the program memory.
the class should also have the comparator flags (membits, which should have a counter so they are cleared (set to 0) after 
the next clock tick, so we can use them for conditional jumps on the next line of code but not after, but remember to use 
component and classes instead of program logic everywhere possible). it will need a decoder that receives the opcode and sends a high on the 
respective wire/index to the ALU, or write enable to the PC. it also needs a 2*numbits register (memory address, called RAMPage)
that we will write to for paging the RAM, so this also needs to be written to from outside (pm or ram). the class will also need
a stack pointer and related registers for function call/return. instead of having one long input and output, I want to
separate them (like PM inputs, RAMPage inputs, flag_inputs, decoder_outputs, etc), and have different functions for connecting 
the different input and output to/from the different devices within. 
the inheriting/child classes will define the opcodes for each different computer, so the 
connections between the decoder and the ALU (and decoder to internal connections like the pc write enable) will be defined
in the child classes, all other connections should be done in this parent class. look at my classes and 
see what type is the best fit for each of the above. if I missed anything else that a control unit should have, let me know

    
- make CPU (ALU+CU):
- make 3-bit computer (print to terminal)
- make GUI for front plate with lights and switches
    program mode/run mode switch
    pulse/auto-run switch
    addr select
    OP code
    C, A, B
    write button
    pulse button
- make automated testing for all parts and components
help me make an automated testing suite that will test all my classes. use the standard industry format inside the testing folder (retain the files currently in that folder)
- create stack pointer, function call and return ability
- keyboard inputs (writes direclty to a register, only one is stored at a time, ignores other inputs until processed)
- make 3-bit computer with screen. 
- make 3-bit pong and snake
- generate base minecraft 4-bit pc (with multiplier, read-only divider subroutine)
- make faceplate addon to see all 16 RAM addr contents (can page?)
- make graphics controllers with char mode :
    - knows to take 3-5 instructions depending on version
    - OR (better) direclty wired to last 4 addresses in RAM ([mode/rgb],[rgb2],[Rpage],[Rsel],[Cpage],[Csel])
      and activate with "write to graphics" command. this allows for 64 colors.
    - 64x64 Color screen: 4 op codes [mode, R, G, B] [RS1-2, CS1-2] [RS3-6] [CS3-6]
    - 128x128 BW screen: 4 op codes [mode, RS0, CS0, data] [RS1-2, CS1-2] [RS3-6] [CS3-6] = 18x25 chars
    - 256x256 
- make 5-bit version with grahics
- make function call and return and pointers (store addr in ram registers and dereference)
- make 8-bit version with Operating System and graphcis
- make 16-bit version with OS and graphcis
- try architecture with all in RAM (and storage) and no program memory


Feb 13 2026
3h components print out parent and variable name
.5h commenting out stack pointer and return addr and removing debug statements
1.5 cpu

Feb 8 2026 :  6.5h total 44h
2h fixing AU add/sub, write enable to mul and div
2h AU inc/dec, mult and truth table tester
.5h ALU and tester
2h comparator and test

Feb 7 2026 : 4h total 37.5h
2h PM loader/verifier
1h main mem loader/verifier
1h arithmetic unit

Feb 6 2026 : 3h total 33.5h
1h PM tester
.5h making program memory 3-data bits in size (use goto ABC)
.5h fixed decoder
1h wasted time with copilot breaking everything

Feb 4 2026 : 2h total 30.5h
1h designing 3-bit ISA

Feb 3 2026 : 3h - total 28.5h
3h designing graphics and opcode architecture

Feb 2 2026 : 2.5h - total: 25.5h
.5 decoder comments
2h Program Memory

Feb 1 2026 : 6h - total: 23h
1.5h comparator
1h logic unit
2h multiplier
.5h divider
1h decoder

Jan 31 2026 : 3h - total: 17h
.5h multi-input XOR
.5h all-component tester utility, testing all components after the changes
.5h adding gitignore, updating git to remove .o and executables
1h >> and <<, register
.5 wrote out ToDo for whole project

Jan 30 2026 : 3h - total: 14h
1.5 Bus, changed components to take numbits so can have multi-bit logic gates and include addr in name
.5 struggling with copilot breaking all the code again. ALWAY BACK IT UP (use git)
1h fixed adder subtractor

Jan 29 2026 : 4h - total: 11h
2h Full_Adder_Subtractor, binary instructions
2h Adder_Subtractor

Jan 28 2026 : 7h - total: 7h
5h Logic Gates and Components Class
1h Half and Full Adder
1h Flip Flop and Memory Bit
